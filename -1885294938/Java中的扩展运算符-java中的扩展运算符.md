---
title: Java中的扩展运算符
date: 2022-02-27 11:24:50.0
updated: 2022-11-04 20:57:08.508
url: /archives/java中的扩展运算符
categories: 
- Javase
tags: 
---



#### 内容简介：以 Java 中的扩展运算符 += 分析扩展运算符的运算方式。

<!--more-->

首先，我们先来看一段代码

~~~java
int i = 10;
i += 10;
System.out.println(i); // 输出结果为 20

int j = 10;
j = j + 10;
System.out.println(j); // 输出结果为 20
~~~

诶，这段代码的 i 和 j 的输出结果都是一样，那是不是说在 Java 中 `i += 10` 的底层运算原理类似于 ` i = i + 10` 呢？我们先来看下下面的一段代码

~~~java
byte b = 10;
b += 10;
System.out.println(b); // 输出结果为 20

byte e = 10;
e = e + 10;     // 哎呀，这里报错了：java: 不兼容的类型: 从int转换到byte可能会有损失
System.out.println(e); 
~~~

这是怎么回事呢？为什么 byte 类型的 b 变量使用 += 运算符自加 10 就不会报错，而同为 byte 类型的 e 变量使用 `e = e + 10` 的方式自加 10 却报错了？

让我们来好好分析一下 e 变量的这一段代码，我们知道，在 Java 中，整数类型的字面量都是默认为 int 类型的，也就是说在 `e = e + 10` 这行代码中，右边的 10 是一个 int 类型的整数，在与 byte类型的 e 变量做加法运算的时候，e 变量要先自动转换成 int 类型的数据再与 10 进行加法运算最终，赋值符号 = 右边的结果是一个 int 类型的数据，而我们的 e 变量是一个 byte 类型的数据，在进行赋值操作时，是由大容量数据类型转换成小容量数据类型，按理来说要进行强制类型转换，但我们的代码中没有进行强制类型转换，所以出现了相应的报错：java: 不兼容的类型: 从int转换到byte可能会有损失

如此说来，+= 运算符的运算方式与 `e = e + 10` 的运算方式还是有不一样的地方的，+= 运算符的运算方式类似于下面的这一段代码

~~~java
byte k = 10;
k = (byte)(k + 10);
System.out.println(k); // 输出结果为 20
~~~

所以，在 Java 中的扩展运算符在进行运算的时候其实都是有进行强制类型转换的。

---

参考材料：[Java零基础教程视频（适合Java 0基础，Java初学入门）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Rx411876f?)